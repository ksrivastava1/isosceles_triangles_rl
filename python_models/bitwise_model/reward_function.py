from numba import njit
import numpy as np
from numba import prange

Lambda = 0.5 # Weight for regularizing the reward function to generate more ones (too high a labda will result in higher odds of generating isosceles triangles)
board_construction = 'spiral' # 'rowwise' or 'spiral'
board_type = 'euclidean' # 'euclidean' or 'torus'

# Helper function for some computations (Can use math.comb() instead if you are using python 3.8 or higher)

@njit
def factorial(n):
    if n == 0 or n == 1:
        return 1
    else:
        return n * factorial(n - 1)
    
@njit
def n_choose_k(n, k):
    if k > n:
        return 0
    else:
        return factorial(n) / (factorial(k) * factorial(n - k))

# Helper function for computing torus distance for later

@njit
def torus_distance(i1, j1, i2, j2, rows, cols):
    # Calculate the minimum distance horizontally
    d1 = abs(j2 - j1)
    d1 = min(d1, cols - d1)

    # Calculate the minimum distance vertically
    d2 = abs(i2 - i1)
    d2 = min(d2, rows - d2)

    # Calculate the torus distance using Pythagorean theorem
    return np.sqrt(d1**2 + d2**2)

@njit
def create_coordinates(n): 
    coordinates = np.empty((n**2, 2))
    for i in prange(n):
        for j in prange(n):
            coordinates[i*n + j, 0] = i
            coordinates[i*n + j, 1] = j
    return coordinates


@njit
def generate_distance_matrix(n):
    if board_type == 'euclidean':
        # Create a meshgrid of the points
        coordinates = np.zeros((n * n, 2), dtype=np.float32)
        for i in prange(n):
            for j in prange(n):
                coordinates[i * n + j, 0] = i
                coordinates[i * n + j, 1] = j

        # Compute pairwise Euclidean distances between points
        dist_matrix = np.zeros((n * n, n * n), dtype=np.float32)
        for i in prange(n * n):
            for j in prange(i, n * n):
                dx = coordinates[i, 0] - coordinates[j, 0]
                dy = coordinates[i, 1] - coordinates[j, 1]
                dist_matrix[i, j] = np.sqrt(dx * dx + dy * dy)
                dist_matrix[j, i] = dist_matrix[i, j]  # Add to the transpose

    elif board_type == 'torus':
        # Compute pairwise distances between points using torus distance
        dist_matrix = np.zeros((n * n, n * n), dtype=np.float32)
        for i in prange(n * n):
            for j in prange(i, n * n):
                row1, col1 = divmod(i, n)
                row2, col2 = divmod(j, n)
                dx = abs(col2 - col1)
                dx = min(dx, n - dx)
                dy = abs(row2 - row1)
                dy = min(dy, n - dy)
                dist_matrix[i, j] = np.sqrt(dx * dx + dy * dy)
                dist_matrix[j, i] = dist_matrix[i, j]  # Add to the transpose

    return dist_matrix

# Useful functions for translating the word representation generated by the agent to the board

@njit
def state_to_word(state, len_word):
    word = np.zeros(len_word, dtype=np.float32)
    for i in prange(len_word):
        word[i] = state[i]
    for i in prange(len_word, 2*len_word):
        if state[i] == 1:
            word[i - len_word] = 1
    return word

@njit
def convert_to_board(word, n):
    word = word.astype(np.float32)  # cast input array to float32
    board = np.zeros((n, n), dtype=np.float32)
    if board_construction == 'rowwise':
        for i in prange(len(word)):
            board[i//n, i%n] = word[i]
    elif board_construction == 'spiral':
        i,j = 0,0 # starting coordinates
        direction = 'right'
        visited = np.zeros((n,n), dtype=np.float32)
        for k in prange(len(word)):
            board[i,j] = word[k]
            visited[i,j] = 1
            if direction == 'right':
                if j + 1 < n and visited[i,j+1] == 0:
                    j += 1
                else:
                    direction = 'down'
                    i += 1
            elif direction == 'down':
                if i + 1 < n and visited[i+1,j] == 0:
                    i += 1
                else:
                    direction = 'left'
                    j -= 1
            elif direction == 'left':
                if j - 1 >= 0 and visited[i,j-1] == 0:
                    j -= 1
                else:
                    direction = 'up'
                    i -= 1
            elif direction == 'up':
                if i - 1 >= 0 and visited[i-1,j] == 0:
                    i -= 1
                else:
                    direction = 'right'
                    j += 1
    return board

# Helper function for counting isosceles triangles later

@njit
def count_elements(row):
    # Initialize an empty dictionary
    d = {}

    # Loop over each element in the row
    for x in row:
        # If the element is already in the dictionary, increment its count
        if x in d:
            d[x] += 1
        # Otherwise, add it to the dictionary with a count of 1
        else:
            d[x] = 1

    # Return the resulting dictionary
    return d

@njit
def count_isosceles_triangles(board, distance_matrix, p):

    # Find indices of all ones on the board
    one_indices = np.flatnonzero(board == 1)
    
    # Compute pairwise distances between all ones and store in a matrix
    # So row i is the distances from the ith one to all other ones

    ones_distance = np.zeros((p, p), dtype=np.float32)

    for i in prange(p):
        for j in prange(i+1,p):
            ones_distance[i,j] = distance_matrix[one_indices[i], one_indices[j]]
            ones_distance[j,i] = ones_distance[i,j]

    # Initialize count of isosceles triangles to zero
    count = 0

    # Check how many repeated distances there are in each row
    # Each repeated distance is an isoceles triangle
    for row in ones_distance:
        hash_table = count_elements(row)
        for key in hash_table:
            temp = hash_table[key] - 1
            if temp == 0 or temp == 1:
                count += temp
                continue
            else:
                temp = np.int(n_choose_k(temp+1, 2))
                count += temp

    return count

# count_isosceles_triangles_manual is a slower version of count_isosceles_triangles that is more space efficient
# since we don't have to store a large n^2 by n^2 matrix of distances

@njit
def count_isosceles_triangles_manual(board, p):
    if board_type == 'euclidean':
        # Find indices of all ones on the board
        one_indices = np.flatnonzero(board == 1)
        
        # Initialize count of isosceles triangles to zero
        count = 0
        
        # Iterate over all pairs of ones
        for i in prange(p):
            for j in prange(i + 1, p):
                for k in prange(j + 1, p):
                    # Calculate the distance between each pair of ones
                    dist_ij = np.sqrt((one_indices[i] // board.shape[0] - one_indices[j] // board.shape[0]) ** 2 +
                                    (one_indices[i] % board.shape[0] - one_indices[j] % board.shape[0]) ** 2)
                    dist_ik = np.sqrt((one_indices[i] // board.shape[0] - one_indices[k] // board.shape[0]) ** 2 +
                                    (one_indices[i] % board.shape[0] - one_indices[k] % board.shape[0]) ** 2)
                    dist_jk = np.sqrt((one_indices[j] // board.shape[0] - one_indices[k] // board.shape[0]) ** 2 +
                                    (one_indices[j] % board.shape[0] - one_indices[k] % board.shape[0]) ** 2)
                    
                    # Check if any two distances are equal (up to a tolerance)
                    if dist_ij == dist_ik or dist_ij == dist_jk or dist_ik == dist_jk:
                        count += 1
    elif board_type == 'torus':
        # Find indices of all ones on the board
        one_indices = np.flatnonzero(board == 1)
        
        # Initialize count of isosceles triangles to zero
        count = 0
        
        # Iterate over all triples of ones
        for i in prange(p):
            for j in prange(i + 1, p):
                for k in prange(j + 1, p):
                    # Calculate the torus distance between each pair of ones
                    dist_ij = torus_distance(one_indices[i] // board.shape[0], one_indices[i] % board.shape[0],
                                             one_indices[j] // board.shape[0], one_indices[j] % board.shape[0],
                                             board.shape[0], board.shape[1])
                    dist_ik = torus_distance(one_indices[i] // board.shape[0], one_indices[i] % board.shape[0],
                                             one_indices[k] // board.shape[0], one_indices[k] % board.shape[0],
                                             board.shape[0], board.shape[1])
                    dist_jk = torus_distance(one_indices[j] // board.shape[0], one_indices[j] % board.shape[0],
                                             one_indices[k] // board.shape[0], one_indices[k] % board.shape[0],
                                             board.shape[0], board.shape[1])
                    
                    # Check if any two distances are equal (up to a tolerance)
                    if dist_ij == dist_ik or dist_ij == dist_jk or dist_ik == dist_jk:
                        print(i,j,k, dist_ij, dist_ik, dist_jk)
                        count += 1

    return count

@njit
def get_score(word, dist_matrix,len_word, n, slow):

    word = word.astype(np.float32)  # cast input array to float32

    # If the size of the word is 2*len_word, then convert it to a word first
    # We need this because in this case, the second half of 'word' contains the information of the one we
    # are considering placing on the board. This places it into the word and we then convert it to a board.

    if len(word) == 2*len_word:
        word = state_to_word(word, len_word)


    board = convert_to_board(word, n)

    # Get the number of 1s on the board
    p = np.sum(board)

    if p >= 3*n:
        return -10000

    # Calculate the number of isosceles triangles on the board
    if slow:
        isosceles = count_isosceles_triangles_manual(board, np.int(p))
    else:
        isosceles = count_isosceles_triangles(board, dist_matrix, np.int(p))

    return -1*(isosceles) + Lambda*(p)

